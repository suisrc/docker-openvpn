#!/bin/bash


# ENV SOCKS5="off" \ 
#     VPN_KEY=a01 \
#     VPN_REGION= \
#     SKIPPED_IPS= \
#     OV_USER_PASS= \
#     OV_CONF_PATH= \
#     OV_CONF_SHELL= \
#     OV_CONF_SHEND= \
#     SUCC_SHELL= \
#     EXIT_SHELL= \
#     HEALTH_SHELL= \
#     HEALTH_URI= \
#     TESTIP_URI=

set -o errexit
set -o nounset
set -o pipefail

cleanup() {
    vpn-stop
}

# 执行配置脚本，在启动前执行
if [[ -n $OV_CONF_SHELL ]]; then
    echo "create openvpn conf by shell: $OV_CONF_SHELL"
    bash -c "$OV_CONF_SHELL"
fi

# OpenVPN OV_USER_PASS include ":", is user:pass, wirte to file
if [[ $OV_USER_PASS == *:* ]]; then
    echo "$OV_USER_PASS" | tr ':' '\n' > /vpn/auth.txt
    OV_USER_PASS=/vpn/auth.txt
fi
# check OpenVPN auth file.
if [[ ! -f $OV_USER_PASS ]]; then
    echo "openvpn auth file not found: $OV_USER_PASS"
    exit 1
fi

# if file is prefix http, download it.
if [[ $OV_CONF_PATH == http* ]]; then
    echo "downloading openvpn conf file: $OV_CONF_PATH"
    curl -ksSL "$OV_CONF_PATH" -o /vpn/openvpn.conf
    OV_CONF_PATH=/vpn/openvpn.conf
fi
if [[ -z "$OV_CONF_PATH" ]]; then
    OV_CONF_PATH=/vpn/openvpn.conf
fi
# check OpenVPN conf file.
if [[ ! -f "$OV_CONF_PATH" ]]; then
    echo "openvpn conf file not found: $OV_CONF_PATH"
    exit 1
fi

# 处理 SKIPPED_IPS
if [[ -n "$SKIPPED_IPS" ]]; then
    echo "using openvpn skip ips: $SKIPPED_IPS"
    echo "$SKIPPED_IPS" | tr ',' '\n' | while read -r line; do
        if [[ $line == */* ]]; then
            # ip/mask => ip mask
            ip=${line%/*}
            mk=${line#*/}
            mk0=$(( (1 << (32 - $mk)) - 1 ))
            mk1=$((mk0 >> 24 & 0xff ^ 0xff))
            mk2=$((mk0 >> 16 & 0xff ^ 0xff))
            mk3=$((mk0 >> 8  & 0xff ^ 0xff))
            mk4=$((mk0 & 0xff ^ 0xff))
            line="$ip $mk1.$mk2.$mk3.$mk4"
        fi
        echo "route $line net_gateway" >> "$OV_CONF_PATH"
    done
fi
# echo "test success: $OV_CONF_PATH" && exit 0

# 修复配置脚本，在启动前执行
if [[ -n $OV_CONF_SHEND ]]; then
    echo "fix openvpn conf by shell: $OV_CONF_SHEND"
    bash -c "$OV_CONF_SHEND"
fi

# 打印启动使用的配置
echo "using openvpn conf file: $OV_CONF_PATH"
echo "using openvpn auth file: $OV_USER_PASS"

# OpenVPN Running.
mkdir /vpn/log
openvpn --config "$OV_CONF_PATH" "--auth-user-pass" "$OV_USER_PASS" &
openvpn_pid=$!
if [[ ! kill -0 "$openvpn_pid" 2>/dev/null ]]; then
    echo "openvpn process not found, openvpn start failed."
    exit 1
fi

trap cleanup TERM

# starting dante socks5 proxy
if [[ "$SOCKS5" == "on" ]]; then
    sleep 5 && vpn-dante openvpn # 延迟5s启动,openvpn启动tun0慢些
fi

# wait $openvpn_pid
#=========================================================
# 成功启动后执行的脚本
if [[ -n "$SUCC_SHELL" ]]; then
  echo "succ shell: $SUCC_SHELL"
  bash -c "$SUCC_SHELL"
fi
if [[ -n "$TESTIP_URI" ]]; then
    sleep 5 && echo "public ip: $(curl -ksSL $TESTIP_URI)"
fi
# 执行健康检查脚本
if [[ -n "$HEALTH_SHELL" ]]; then
    # 默认是5s检查一次,但是可以在 HEALTH_SHELL 中增加 sleep x 来调整检查频率
    # 推荐采用 5+25 的方式, 在 HEALTH_SHELL 中 sleep 25
    # 如果$openvpn_pid进程不存在，说明openvpn已经退出
    while kill -0 "$openvpn_pid" 2>/dev/null; do
        sleep 5 && bash -c "$HEALTH_SHELL" # 不忽略异常，异常会触发重启
    done
else
    wait $openvpn_pid
    # --wait
fi
echo "exit openvpn"
