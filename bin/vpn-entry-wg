#!/bin/ash

# ENV SOCKS5="off" \ 
#     VPN_KEY=a01 \
#     VPN_REGION= \
#     SKIPPED_IPS= \
#     WG_PRIVATE_KEY= \
#     WG_ADDRESS_KEY= \
#     WG_ADDRESS_DNS="1.1.1.1,8.8.8.8"\
#     WG_ADDRESS_MTU= \
#     WG_PEER_ENDPOINT= \
#     WG_PEER_PUBLIC_KEY= \
#     WG_PEER_ALLOWED_IPS="0.0.0.0/0"\
#     WG_PEER_KEEPALIVE= \
#     WG_CONF_PATH= \
#     WG_CONF_SHELL= \
#     WG_CONF_SHEND= \
#     SUCC_SHELL= \
#     EXIT_SHELL= \
#     HEALTH_SHELL= \
#     HEALTH_URI= \
#     TESTIP_URI=

set -o errexit
set -o nounset
set -o pipefail

cleanup() {
    vpn-stop
}

# 执行配置脚本，在启动前执行
if [[ -n "$WG_CONF_SHELL" ]]; then
    echo "create openvpn conf by shell: $WG_CONF_SHELL"
    ash -c "$WG_CONF_SHELL"
fi

# if file is prefix http, download it.
if [[ $WG_CONF_PATH == http* ]]; then
    echo "downloading wireguard conf file: $WG_CONF_PATH"
    curl -ksSL "$WG_CONF_PATH" -o /vpn/wireguard.conf
    WG_CONF_PATH=/vpn/wireguard.conf
fi

# 如果 WG_CONF_PATH 不存在，通过环境变量创建
if [[ ! -f $WG_CONF_PATH ]]; then
    if [[ -z "$WG_PRIVATE_KEY" ]]; then
        echo "missing wireguard private key"
        exit 1
    fi
    if [[ -z "$WG_ADDRESS_KEY" ]]; then
        echo "missing wireguard address key"
        exit 1
    fi
    if [[ -z "$WG_PEER_PUBLIC_KEY" ]]; then
        echo "missing wireguard peer public key"
        exit 1
    fi
    if [[ -z "$WG_PEER_ENDPOINT" ]]; then
        echo "missing wireguard peer endpoint"
        exit 1
    fi
    # write interface
    cat <<EOF > /vpn/wireguard.conf
[Interface]
PrivateKey = $WG_PRIVATE_KEY
Address = $WG_ADDRESS_KEY
DNS = $WG_ADDRESS_DNS

EOF
    if [[ -n "$WG_ADDRESS_MTU" ]]; then
        echo "MTU = $WG_ADDRESS_MTU" >> /vpn/wireguard.conf
    fi
    # write peer
    cat <<EOF >> /vpn/wireguard.conf

[Peer]
PublicKey = $WG_PEER_PUBLIC_KEY
AllowedIPs = $WG_PEER_ALLOWED_IPS
Endpoint = $WG_PEER_ENDPOINT

EOF
    if [[ -n "$WG_PEER_KEEPALIVE" ]]; then
        echo "PersistentKeepalive = $WG_PEER_KEEPALIVE" >> /vpn/wireguard.conf
    fi
    # write end
    WG_CONF_PATH=/vpn/wireguard.conf
fi
echo "test success: $WG_CONF_PATH" && exit 0
ln -sf "$WG_CONF_PATH" /etc/wireguard/wg0.conf

if [[ -n "$WG_CONF_SHEND" ]]; then
    echo "fix wireguard conf shell: $WG_CONF_SHEND"
    ash -c "$WG_CONF_SHEND"
fi

# 处理 SKIPPED_IPS
if [[ -n "$SKIPPED_IPS" ]]; then
    echo "using wireguard skip ips: $SKIPPED_IPS"
    default_gw=$(ip route show | grep via | awk '{print $3}')
    IFS=',' read -ra skip_ips <<< "$SKIPPED_IPS"
    for skip_ip in "${skip_ips[@]}"; do
        echo "[+] ip route add $skip_ip via $default_gw"
        ip route add "$skip_ip" via "$default_gw"
    done
fi

echo "using wireguard conf file: $WG_CONF_PATH"

wg-quick up wg0
if [[ ! -e /sys/class/net/wg0 ]]; then
    echo "wg0 not found, wireguard start failed."
    exit 1
fi

# 显示连接状况
sleep 1 && wg show
echo "" && echo "wg0 is installed"

trap cleanup TERM

# starting dante socks5 proxy
if [[ "$SOCKS5" == "on" ]]; then
    sleep 1 && vpn-dante wireguard # 基本不需要延迟， wireguard 启动wg0很快
fi

#=========================================================
# 成功启动后执行的脚本
if [[ -n "$SUCC_SHELL" ]]; then
  echo "succ shell: $SUCC_SHELL"
  ash -c "$SUCC_SHELL"
fi
if [[ -n "$TESTIP_URI" ]]; then
    sleep 3 && echo "public ip: $(curl -ksSL $TESTIP_URI)"
fi
# 执行健康检查脚本
if [[ -n "$HEALTH_SHELL" ]]; then
    # 默认是5s检查一次,但是可以在 HEALTH_SHELL 中增加 sleep x 来调整检查频率
    # 推荐采用 5+25 的方式, 在 HEALTH_SHELL 中 sleep 25
    # 如果/sys/class/net/wg0不存在，说明wireguard已经退出
    while [[ -e /sys/class/net/wg0 ]]; do
        sleep 5 && ash -c "$HEALTH_SHELL" # 不忽略异常，异常会触发重启
    done
else
    # monitor wg-quick down wg0， 检查wg0是否卸载
    while [[ -e /sys/class/net/wg0 ]]; do sleep 5 done
    # while true; do sleep 5 && echo `date`; done
fi
echo "exit wireguard"
